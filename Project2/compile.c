// Compiler Builder 1:
// Matthew Carlino
// Jacob Solomon
// Joseph Freeman
// Alex Arwin
// Ryan Rossbach

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <ctype.h>

int main(void)
{
    // 2 command line arguments
    // input: is the PL/0 code 
    // output: is file containing the PM/0 code generated by your compiler
    
    // main calls program
    // program calls block recursively
    program();
    return 0;
}

// Appendix D
void program()
{
    advance();
    block();
    if (tok != periodsym)
        error();
    // advance();
    // printf("Tiny PL/0 program is syntactically correct\n");
}

// Appendix D
void block()
{

    if(tok == constsym) {
        do {
            advance();
            if(tok != identsym)     // Error: expected identifer in constant declaration
                error();
            advance();
            if(tok != eqsym)
                error();            // Expected '=' after 
            advance();
            if(tok !+ numbersym)
                error();
            advance();
        } while(tok == commasym)

        if(tok != semicolonsym)
            error();
        advance();
    }

    if(tok == varsym) {
        do {
          advance();

          if(tok != identsym)
                error();            // Expected identifer in variable declaration
        } while(tok == commasym)

        if(tok != semicolonsym)
            error();                // Expected ';' at the end of variable declaration
        advance();
    }

    while(tok == procsym) {
        advance();

        if(tok != identsym)
            error();
        advance();

        if(tok != semicolonsym)
            error();
        advance();
        block();

        if(tok != semicolonsym)
            error();
        advance();
    }

    statement();

}

void const_declaration()
{
    if (tok != constsym)
        return;
    advance();

    if (tok != identsym)
        error();
    advance();
    ident();

    if (tok != equalsym) // "="
        error();
    advance();

    if (tok != numbersym)
        error();
    advance();

    while (tok == commasym) {
        advance();

        if (tok != identsym)
            error();
        advance();
        ident();

        if (tok != equalsym) // "="
            error();
        advance();

        if (tok != numbersym)
            error();
        advance();
        number();
    }

    if (tok != semicolonsym)
        error();
    advance();
}

void var_declaration() {

    if (tok != varsym)
        return;
    advance();

    if (tok != identsym)
	error();
    advance();

    while (tok == commasym) {
        advance();
        if (tok != identsym)
            error();
        advance();
    }

    if (tok != semicolonsym)
        error();
    advance();
}

// Appendix D
void statement()
{
    if (tok == identsym) {
        advance();
        if (tok != becomessym)
            error();
        advance();
        // need to call advance() in expression
        expression();
    }

    else if(tok == callsym) {
        advance();
        if(tok != identsym)
            error();
        advance();
    }

    else if (tok == beginsym) {
        advance();
        statement();

        while (tok == semicolonsym) {
            advance();
            statement();
        }

        if(tok != endsym)
            error();
        advance();
    }

    else if (tok == ifsym) {
        advance();
        condition();

        if (tok != thensym)
            error();
        advance();
        statement();
    }

    else if (tok == whilesym) {
        advance();
        condition();

        if (tok != dosym)
            error();
        advance();
        statement();
    }

    else if (tok == readsym) {
        advance();
        if (tok != identsym)
            error();
        indent();
    }

    else if (tok == writesym) {
        advance();
        if (tok != identsym)
            error();
        ident();
    }
}

// Appendix D
void condition()
{
    if (tok == oddsym) {
        advance();
        expression();
    }

    else {
        expression();
        if(tok != relation())
            error();
        advance();
        expression();
    }
}

void rel_op()
{
    switch(tok)
	case equalsym:
	    advance();
	    return;
	case neqsym:
	    advance();
	    return;
	case lesssym:
	    advance();
	    return;
	case leqsym:
	    advance();
	    return;
	case gtrsym:
	    advance();
	    return;
	case geqsym:
	    advance();
	    return;
	default:
	    error();
}

// Still have a few functions I need to finish / double check
// Think the majority of them are pretty set though

// Appendix D .
void expression()
{

    if(tok == plussym || tok == minussym)
        advance();
    term();
    while(tok == plussym || tok == minussym) {
        advance();
        term();
    }
}

// Appendix D
void term()
{
    factor();

    while(tok == multsym || tok == slashsym) {
        advance();
        factor();
    }
}

// factor ::= ident | number | "(" expression ")" .
void factor()
{

    if(tok == identsym)
        advance();

    else if(tok == number())
        advance();

    else if(tok == lparensym) {
        advance();
        expression();
        if(tok != rparensym)
            error();
    }

}

// number ::= digit {digit}.
void number()
{

    digit();
    while(digit()) {
        advance();
    }

}

//ident ::= letter {letter | digit}.
void ident()
{
    letter();

}

//digit ::= “0” | “1” | “2” | “3” | “4” | “5” | “6” | “7” | “8” | “9” .
void digit()
{

   if(isdigit(tok))
        advance();

}

//letter ::= “a” | “b” | ... | “y” | “z” | “A” | “B” | ... | “Y” | “Z”.
void letter()
{

    if(isalpha(tok))
        advance();

}

void error(int error) {
    
    // list of errors:
    
    switch(error)
    {
	case 1: // use = instead of :=
	    printf("Error number 1, use = instead of :=\n");
	    break;
	case 2: // = must be followed by a number
	    printf("Error number 2, = must be followed by a number\n");
	    break;
	case 3: // Identifier must be followed by =
	    printf("Error number 3, identifier must be followed by =\n");
	    break;
	case 4: // 'const', 'var', 'procedure' must be followed by identifier
	    printf("Error number 4, 'const', 'var', 'procedure' must be followed by identifier\n");
	    break;
	case 5: // semicolon or comma missing
	    printf("Error number 5, semicolon or comma missing\n");
	    break;
	case 6: // incorrect symbol after procedure declaration
	    printf("Error number 6, incorrect symbol after procedure declaration\n");
	    break;
	case 7: // statement expected
	    printf("Error number 7, statement expected\n");
	    break;
	case 8: // incorrect symbol after statement part in block
	    printf("Error number 8, incorrect symbol after statement part in block\n");
	    break;
	case 9: // period is expected
	    printf("Error number 9, period is expected\n");
	    break;
	case 10: // semicolon between statements missing
	    printf("Error number 10, semicolon between statements missing\n");
	    break;
	case 11: // undeclared identifier
	    printf("Error number 11, undeclared identifier\n");
	    break;
	case 12: // assignment to constant or procedure is not allowed
	    printf("Error number 12, assignment to constant or procedure is not allowed\n");
	    break;
	case 13: // assignment operator expected
	    printf("Error number 13, assignment operator expected\n");
	    break;
	case 14: // 'call' must be followed by an identifier
	    printf("Error number 14, 'call' must be followed by an identifier\n");
	    break;
	case 15: // call of a constant or variable is meaningless
	    printf("Error number 15, call of a constant or variable is meaningless\n");
	    break;
	case 16: // 'then' expected
	    printf("Error number 16, 'then' expected\n");
	    break;
	case 17: // semicolon or '}' expected
	    printf("Error number 17, semicolon or '}' expected\n");
	    break;
	case 18: // 'do' expected
	    printf("Error number 18, 'do' expected\n");
	    break;
	case 19: // incorrect symbol following statement
	    printf("Error number 19, incorrect symbol following statement\n");
	    break;
	case 20: // relational operator expected
	    printf("Error number 20, relational operator expected\n");
	    break;
	case 21: // expression must not contain a procedure identifier
	    printf("Error number 21, expression must not contain a procedure identifier\n");
	    break;
	case 22: // right parenthesis missing
	    printf("Error number 22, right parenthesis missing\n");
	    break;
	case 23: // the preceding factor cannot begin with this symbol
	    printf("Error number 23, the preceding factor cannot begin with this symbol\n");
	    break;
	case 24: // an expression cannot begin with this symbol
	    printf("Error number 24, an expression cannot begin with this symbol\n");
	    break;
	case 25: // this number is too large
	    printf("Error number 25, this number is too large\n");
	    break;
	default:
	    printf("There has been an error\n");
    }
    
    exit(0);

}

